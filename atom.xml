<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codingbear.top</id>
    <title>琢钰</title>
    <updated>2021-08-11T12:58:49.301Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codingbear.top"/>
    <link rel="self" href="https://codingbear.top/atom.xml"/>
    <subtitle>玉不琢，不成器。人不学，不知义。</subtitle>
    <logo>https://codingbear.top/images/avatar.png</logo>
    <icon>https://codingbear.top/favicon.ico</icon>
    <rights>All rights reserved 2021, 琢钰</rights>
    <entry>
        <title type="html"><![CDATA[马来西亚华人]]></title>
        <id>https://codingbear.top/ma-lai-xi-ya-hua-ren/</id>
        <link href="https://codingbear.top/ma-lai-xi-ya-hua-ren/">
        </link>
        <updated>2021-08-11T12:57:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="马来西亚华人">马来西亚华人</h1>
<p>第一波    郑和下西洋 男的峇峇 女的娘惹<br>
第二波    1860 英国殖民需要在马来大量的苦力  英法联军打入北京 俄国阻止  割让150万平方公里土地  北京条约 允许中国国民海外&quot;工作&quot;  从中国贩卖奴隶<br>
第三波    民国时期 中国动荡 逃难 孙中山革命根据地就在南洋    黄花岗起义 七十二烈士 一半都是马来西亚华人<br>
最早的华文学校 槟城 五福书院<br>
英国殖民 让你干苦力 没让你学习！  打压</p>
<p>林连玉 马来西亚华文教育之父 族魂</p>
<p>为华文教育和牺牲，永不后悔！<br>
尊孔学校教书   1941 日本侵略  华人支持抗日 杀！  参加了保卫马来的活动  负伤去养猪<br>
1946 日本人走了  重新开办学校  养猪的钱全捐了=老师上班不要工资 还捐钱给学校<br>
英国人再次跑回来殖民<br>
1951  巴恩报告书   消灭华文学校<br>
全马华校教师会总会</p>
<p>陈六使 新加坡福建会馆主席</p>
<p>捐钱500W捐地  南洋车夫 舞女 义卖  全部的钱建学校</p>
<p>1955 南洋大学</p>
<p>没有政府资助，华教的文凭才全世界受到承认，唯独马来西亚不承认。马来西亚根据种族区分，华人根本很难上到国立大学，但是马来西亚华人仍然让他们的孩子读华教！</p>
<p>新加坡 国语是马来语 (从马来独立出去的呗) 官方语言 英文   南洋大学</p>
<p>日常语言 很奇怪的咖喱味英语  保留鞭刑</p>
<h1 id="马来西亚为什么不要新加坡">马来西亚为什么不要新加坡？</h1>
<p><strong>1.新加坡华人很多</strong></p>
<p><strong>2.新加坡当时的共产主义很流行</strong></p>
<p>3.<strong>李光耀提倡‘马来西亚人的马来西亚’，而马来西亚提倡的是‘马来人的马来西亚’</strong></p>
<p><strong>4.种族暴乱</strong></p>
<p><strong>5.经济利益纠纷（马来西亚没有对新加坡开放市场）</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[东奥所感]]></title>
        <id>https://codingbear.top/dong-ao-suo-gan/</id>
        <link href="https://codingbear.top/dong-ao-suo-gan/">
        </link>
        <updated>2021-07-30T13:00:50.000Z</updated>
        <content type="html"><![CDATA[<p>本来奥运会该是一件无比凝聚国民力量，可以让我们更加有民族自豪感的事。可是这几天下来，突然让我产生了厌烦中国人的情绪。开始让我觉得中国人好像倾向于人多就是对，热评第一的绝对话语权，情绪大于天，理性次次次次之的感觉。</p>
<p>首先是那个体操打分的事，加上日本糟糕的疫情管理，还有核废水问题，加上一堆的杂七杂八稀巴烂的问题，我也来了很多情绪。就写下了希望我们可以强硬一点，还不如退赛，在这样的环境下运动员的身体根本保证不了。抗议解决不了实际问题不要强国只是说也要做给世界看，然后就被认为是质疑我们国家的强大，甚至被说成了精日，但其实这我都可以理解，毕竟她的出发点还是爱国吧。</p>
<p>然后又看到了今天的热搜，《抗日奇侠》评分上涨，我本来看着觉得也就是一件挺有意思的“自发运动”，可是又看了那些”凭什么打一星，打一星的都是二鬼子“等等的诸如此类的言论就突然恶心起来了，我理解你们的行为，可真的因为这种所谓的抗日情绪就可以只有你们的行为才是对的吗？这样的抗日神剧分那么高，那那些认认真真写剧本认认真真拍片子的抗日剧呢？他们的逻辑好像就只是我打五星你也得打五星，现在就是抗日NO.1，我管你什么公平不公平，你打一星就是二鬼子就是精日......</p>
<p>还有最近吵得火热的伊藤美诚事件，这也可能是最恶心我的事，我真的认为我们自封为的”文明古国“不该如此。我真的搜了半天伊藤美诚做了啥，本来唯一觉得过分的就是她回国以后黑中国，然后发现人家说的只是饭菜吃不惯严格的防疫很辛苦诸如此类的，感谢我们中国伟大的营销号翻译成了中国全是细菌，大家也看个截图就全信了，我就不信了，起码我一个只有奥运会看乒乓球的人在混双决赛之前真的不认识她，我相信大部分网民也一样，比赛完了就是疯狂攻击人家女生笑就是贱捋头发就是不懂尊重，我不理解......都不认识她，可否了解了再发言呢？直到后来攻击她成了政治正确，网暴人家女生当成功绩在吹嘘，我不理解......她的妈妈每天告诉她只有你才能打败中国，把中国当成很强大的对手，这难道不是给自己一个远大目标吗？一个个就指指点点说她妈教育真可怕，甚至又当成嘲讽的点，我不理解.......还有那张什么中国国辱的报纸，你自己随便一搜来源就知道，产经新闻，日本极右翼，但这舆论攻击我是支持的，起码要那个傻逼报纸道歉为止......可是现在的群情激愤已经根本不受控制了，看了张截图就高潮......以后你们会道歉吗？也许永远都不会的吧</p>
<p>还有就是当时混双输了，大家都在讨论什么你们都是我们的骄傲，运动员该不该道歉什么的。有人把李娜的一个视频放了出来，大概就是一个记者问&quot;这次比赛输的这么早，有什么话想对国内的粉丝说吗？&quot;。李娜张口就是:”我没什么好说的，就输了个比赛而已，我需要三跪九叩道歉吗？“。然后被当成了女王行为，各种吹。难道这不是情商低行为？就算那个记者是故意引导，在人家没把坑挖出来之前，你自己跳进去那就是你情商低。而且在我看来那就是情商低，所有的粉丝都是要你道歉的吗？想知道你自己的心态自己的状况的没有？你就不能说一句只是输了一场比赛我很好大家不用担心？反正就记者的这个问题我觉得并不过分，李娜这也绝对算不得什么榜样。还被拿来和王菲比，王菲的女王发言个个有理有据，从来都是记者先发难。我的想法也就只是这样，我就评论了一句”我并不赞同以上发言“，就是各种”你配吗？“。再加上这两天热搜天天都在讨论这个该不该道歉，我觉得媒体就是吃饱了没事干在这里瞎引导，说一句让期待我的人失望了这算不算道歉？三跪九叩又算不算道歉？良性关系不是这么引导的。互相理解才是对的吧，当然这也只是我的看法。</p>
<p>还有今天看的微博。有个人因为南京疫情管理很失望，就激动之下骂了一句南京不死点人不足以平民愤之类的话，我承认这很过激，可我没想到的是直接抓去刑事拘留了，搞得她的弟弟肯定书是读不上了。我总觉得做事要看出发点，她明显只是气愤疫情管理，而且警方通报也写了挺配合的，抓过去训个话签个悔过书，实在不行行拘几天，刑拘我觉得真的有点过了......</p>
<p>唉，这是第一次觉得中国人有时候真的挺可怕的。第一次觉得好像我们的国家更像我们嗤之以鼻的粉圈。但或许只是我想多了，只是微博永远是粉圈，正常人永远不在微博掌握话语权罢了。</p>
<p>下面由我发表正常人类的非正常过激发言<br>
操你妈的在你中国爸爸身上游的废物<br>
操你妈的平时在你中国爸爸面前屁都不敢放一句的在地图上搞小动作<br>
操你妈的身残志坚垃圾裁判<br>
操你妈的脑残日本政府吃你妈的核废水去吧<br>
操你妈的智障日本政府全世界都知道你们贪污你们还好意思办比赛呢<br>
脸 都 不 要 了   顔はもういらないです</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[十年]]></title>
        <id>https://codingbear.top/shi-nian/</id>
        <link href="https://codingbear.top/shi-nian/">
        </link>
        <updated>2021-05-21T02:11:01.000Z</updated>
        <content type="html"><![CDATA[<center><h1>重逢</h1></center>
<center><b>吴念真</b></center>
<p>事业失败之后才发现，除了开车之外，自己好像连说得出口，拿得出手的专长都没有，所以最后他选择了开计程车。</p>
<p>只是没想到台北竟然这么小，计程车在市区里跑还是容易碰到以前商场上的客户或对手，“熟人不收费，自己倒贴时间和油钱这不算什么，最怕遇到的是以前的对手，车资两百三给你三百块，奉送一句：不必找啦，留着用！外加一个奇怪的眼神和笑容，那种窝囊感让人觉得别人死了算了。”</p>
<p>所以后来他专跑机场，说比较不会遇到类似难堪的状况，而且也不用整天在市区没目的地逛，让自己老觉得像一个已经被这个战场淘汰的残兵败将，或者像中年游民一般感到无望。</p>
<p>不过，他也承认跑机场的另一个奢望是，如果前妻带着孩子们偷偷回台的话，说不定还有机会和孩子们见上一面。“离婚后就没见过……我只能凭空想象他们现在的样子。”</p>
<p>孩子和前妻一直没碰上，没想到先碰到的反而是昔日的恋人。</p>
<p>他说那天车子才靠近，他就认出她来了。“曾经那么熟悉的脸孔和身体……而且除了发形，十几二十年她好像一点也没变。”</p>
<p>上车后，她只说了一个医院的名字和“麻烦你”之后，就沉默地看着窗外，反而是他自己一直担心会不会因为车子里的名牌而被她认出来。不过，她似乎没留意，视线从窗外的风景收回来之后，便拿出电话打。</p>
<p>第一通电话听得出她是打回澳洲雪梨的家，听得出先生出差去了英国。她轮流跟两个孩子说话，要一个男孩不要为了打球而找借口不去上中文课，还要一个女孩好好练钢琴，不然表演的时候会出糗，然后说见到外婆之后会替他们跟她说爱她等等，最后才听出是她母亲生病了，因为她说：“我还没到医院，不过妈妈相信外婆一定会很平安。”</p>
<p>他还记得她母亲的样子和声音，以及她做的一手好菜，更记得两人分手后的某一天，她到公司来，哽咽地问他：“你怎么可以这样对待我女儿呢？”那种颤抖的语气和哀怨的眼神。</p>
<p>打完家里的电话，接着打给她的公司，利落的英文、明确的指令加上自然流露对同事的关心，一如既往。</p>
<p>他们大学时候就是朋友，毕业之后他去当兵，而她在外商公司做事；他退伍后，她把一些客户拉过来，两个人合伙做。三年后，公司从两个人增加到二十几个人，生意大有起色，而他却莫明其妙和一个客户的女儿发生了一夜情……</p>
<p>“说莫明其妙其实是借口。”他说：“到现在也没什么好不承认的……一来是新的身体总比熟悉的刺激，还有……这个客户公司的规模是我的几百倍，那时不是流行一句话：娶对一个老婆可以省掉几十年的奋斗？”</p>
<p>最后车子经过敦化南路，经过昔日公司的办公室，两旁的台湾栾树正逢花季，灿烂的秋阳下一片亮眼的金黄。</p>
<p>后座当年的爱人正跟之前公司的某个同事话家常，说台北，说澳洲，说孩子，说女人到了这个年龄阶段的感受，然后说停留的时间以及相约见面吃饭，说：“让我看看你们现在都变成什么模样。”</p>
<p>车子最后停在医院门口，他还在躲避，也犹豫着要不要跟她收费或者给她打个折，没想到后头的女人忽然出声，笑笑地用极其平静的语气跟他说：“我都已经告诉你我所有近况，告诉你我现在的心情，告诉你我对一些人的思念……什么都告诉你了，而你……连一声hello都不肯跟我说？</p>
<blockquote>
<p>突然在虎扑看到了十年背景故事的讨论。看了这个故事可能也更加理解了这首歌。最颤抖的两个字就是你好。</p>
</blockquote>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<iframe src="//player.bilibili.com/player.html?aid=22014706&bvid=BV1AW411T7uy&cid=36381033&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">
 </iframe>
</div>
<br/>
<br/>
<br/>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总复习08-数据库]]></title>
        <id>https://codingbear.top/zong-fu-xi-08-shu-ju-ku/</id>
        <link href="https://codingbear.top/zong-fu-xi-08-shu-ju-ku/">
        </link>
        <updated>2020-11-07T13:08:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dql">DQL</h2>
<h3 id="基础查询">基础查询</h3>
<pre><code class="language-SQL">SELECT 查询列表 FROM 表名；
</code></pre>
<p>查询的结果集是一个虚拟表</p>
<p>▲执行顺序</p>
<ol>
<li>FROM子语句</li>
<li>SELECT子语句</li>
</ol>
<h4 id="查询列表">查询列表</h4>
<ol>
<li>
<p>查询常量</p>
<pre><code class="language-SQL">SELECT 100;
</code></pre>
</li>
<li>
<p>查询表达式\</p>
<pre><code class="language-SQL">SELECT 100%3;
</code></pre>
</li>
<li>
<p>查询单个字段</p>
<pre><code class="language-SQL">SELECT last_name FROM employees;
</code></pre>
</li>
<li>
<p>查询多个字段</p>
<pre><code class="language-SQL">SELECT last_name,email,employee_id FROM employees;
</code></pre>
</li>
<li>
<p>查询所有字段</p>
<pre><code class="language-SQL">SELECT * FROM employees;
</code></pre>
</li>
<li>
<p>查询函数（调用函数，获取返回值）</p>
<pre><code class="language-SQL">	SELECT DATABASE();
	SELECT VERSION();
	SELECT USER();
</code></pre>
</li>
</ol>
<p>####起别名</p>
<ol>
<li>使用as关键字</li>
<li>使用空格</li>
</ol>
<h4 id="加号的作用">加号的作用</h4>
<ol>
<li>加法运算
<ul>
<li>两个操作数都是数值型</li>
<li>其中一个操作数为字符型，如果无法转换直接当做0处理</li>
<li>其中一个操作数为null，结果都是null</li>
</ul>
</li>
</ol>
<p><strong>字符的拼接不能用+号，应该用CONCAT函数</strong></p>
<h4 id="distinct的使用">distinct的使用</h4>
<p>写在需要去重的字段名前</p>
<h4 id="查看表的结构">查看表的结构</h4>
<pre><code class="language-SQL">	DESC employees;
	SHOW COLUMNS FROM employees;
</code></pre>
<h4 id="ifnull函数">ifnull函数</h4>
<p>ifnull(commission_pct,‘空’),如果为空则显示后面的值，不为空则显示本身。</p>
<h3 id="条件查询">条件查询</h3>
<blockquote>
<p>语法：</p>
<p>SELECT 查询列表<br>
FROM 表名<br>
WHERE 查询条件</p>
</blockquote>
<p>▲执行顺序</p>
<ol>
<li>FROM子句</li>
<li>WHERE子句</li>
<li>SELECT子句</li>
</ol>
<h4 id="按关系表达式查询">按关系表达式查询</h4>
<p><strong>SQL中的不等于号用&lt;&gt;!!</strong><br>
!=也可，但兼容性不如&lt;&gt;。</p>
<h4 id="按逻辑表达式查询">按逻辑表达式查询</h4>
<p>逻辑运算符：and or not 兼容&amp;&amp; || !但同样不建议</p>
<h4 id="模糊查询">模糊查询</h4>
<p>like /in /between and /is null</p>
<h4 id="排序查询">排序查询</h4>
<blockquote>
<p>语法：</p>
<p>SELECT 查询列表<br>
FROM 表名<br>
[WHERE 筛选条件]<br>
ORDER BY 排序列表</p>
</blockquote>
<p>▲执行顺序</p>
<ol>
<li>from子句</li>
<li>where子句</li>
<li>select子句</li>
<li>order by子句</li>
</ol>
<p><strong>DESC 降序 ASC升序</strong> 默认升序</p>
<pre><code class="language-SQL">SELECT last_name,salary,department_id
FROM employees
ORDER BY salary,department_id DESC;
</code></pre>
<p>salay还是默认升序，DESC只对一个字段起作用。建议加上AS语义性更强。</p>
<ul>
<li>
<p>排序方式</p>
<ol>
<li>
<p>按单个字段排序</p>
</li>
<li>
<p>按表达式排序</p>
</li>
<li>
<p>按别名排序</p>
</li>
<li>
<p>按函数的结果排序</p>
</li>
<li>
<p>按多个字段排序</p>
</li>
<li>
<p>按列数排序 ORDET BY后面直接加数字代表第几列</p>
<pre><code class="language-SQL">SELECT *
FROM employees
ORDER BY 2;
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="常见函数">常见函数</h3>
<ol>
<li>
<p>字符函数</p>
<ul>
<li>
<p>CONCAT 拼接字符</p>
</li>
<li>
<p>LENGTH 获取字节长度</p>
</li>
<li>
<p>CHAR_LENGTH 获取字符长度</p>
</li>
<li>
<p>SUBSTRING 截取子串</p>
<p>SUBSTR(str,起始索引,截取的字符长度)</p>
<p>SUBSTR(str,起始索引)</p>
</li>
<li>
<p>INSTR 获取字符第一次出现的索引</p>
</li>
<li>
<p>TRIM 去前后指定的字符，默认是去空格</p>
<pre><code class="language-SQL">SELECT TRIM('x' FROM 'xxxxxxxxxMINIGxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') as a;
</code></pre>
</li>
<li>
<p>LPAD/RPAD 左填充/右填充</p>
<pre><code class="language-SQL">SELECT LPAD('周杰伦',10,'NB');
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/10/26/GIMy8d3bFtiR5Hl.png" alt="image-20201026001322094" loading="lazy"></figure>
</li>
<li>
<p>UPPER/LOWER 大写/小写</p>
</li>
<li>
<p>STRCMP 比较两个字符大小</p>
</li>
<li>
<p>LEFT/RIGHT 截取子串</p>
</li>
</ul>
</li>
<li>
<p>数学函数</p>
<ul>
<li>ABS 绝对值</li>
<li>CEIL 向上取整</li>
<li>FLOOR 向下取整</li>
<li>ROUND 四舍五入</li>
<li>TRUNCATE 截断  小数点后保留几位</li>
<li>MOD 取余</li>
</ul>
</li>
<li>
<p>日期函数</p>
<ul>
<li>NOW  获取当前时间+日期</li>
<li>CURDATE 获取日期</li>
<li>CURTIME 获取当前时间</li>
<li>DATEDIFF 获取时间差</li>
<li>DATE_FORMAT 格式化时间日期</li>
<li>STR_TO_DATE 按指定的格式解析字符串为日期类型</li>
</ul>
</li>
<li>
<p>流程控制函数</p>
<ul>
<li>IF</li>
<li>CASE WHEN</li>
</ul>
</li>
<li>
<p>分组函数</p>
<blockquote>
<p>往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数。</p>
</blockquote>
<ul>
<li>
<p>SUM 求和函数</p>
</li>
<li>
<p>AVG</p>
</li>
<li>
<p>MAX</p>
</li>
<li>
<p>MIN</p>
</li>
<li>
<p>COUNT 计算数据个数函数</p>
<pre><code class="language-SQL">COUNT(1)
COUNT(*)
同样的效果相当于多加了一列全是1
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="分组查询">分组查询</h3>
<blockquote>
<p>语法：</p>
<p>SELECT 查询列表</p>
<p>FROM 表名</p>
<p>WHERE 筛选条件</p>
<p>GROUP BY 分组列表</p>
<p>ORDER BY 排序列表;</p>
<p>特点：</p>
<ol>
<li>查询列表往往是分组函数和被分组的字段</li>
<li>分组前筛选用WHERE,分组后筛选用HAVING。</li>
</ol>
</blockquote>
<p>▲执行顺序</p>
<ol>
<li>from子句</li>
<li>where子句</li>
<li>group by子句</li>
<li>having子句</li>
<li>select子句</li>
<li>order by子句</li>
</ol>
<h3 id="连接查询">连接查询</h3>
<h4 id="分类">分类</h4>
<ul>
<li>按年代分类
<ul>
<li>SQL92标准：仅仅支持内连接</li>
<li>SQL99标准</li>
</ul>
</li>
<li>按功能分类
<ul>
<li>内连接
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li>外连接
<ul>
<li>左外连接</li>
<li>右外连接</li>
<li>全外连接</li>
</ul>
</li>
<li>交叉连接</li>
</ul>
</li>
</ul>
<h4 id="sql92语法">SQL92语法</h4>
<ol>
<li>
<p>内连接</p>
<ul>
<li>
<p>等值连接</p>
<blockquote>
<p>语法：</p>
<p>SELECT 查询列表<br>
FROM 表名1，表名2,....<br>
WHERE 等值连接的连接条件</p>
<p>特点：</p>
<ol>
<li>为了解决多表中的字段名重名问题，往往为表起别名，提高了语义性</li>
<li>表的顺序无要求</li>
</ol>
</blockquote>
</li>
<li>
<p>非等值连接</p>
</li>
<li>
<p>自连接</p>
</li>
</ul>
</li>
</ol>
<h4 id="sql99语法">SQL99语法</h4>
<ol>
<li>内连接</li>
</ol>
<blockquote>
<p>语法：<br>
SELECT 查询列表<br>
FROM 表名1 别名<br>
【INNER】 JOIN 表名2 别名<br>
ON 连接条件<br>
WHERE 筛选条件<br>
GROUP BY 分组列表<br>
HAVING 分组后筛选<br>
ORDER BY 排序列表;</p>
</blockquote>
<p>SQL92与SQL99的区别：</p>
<p>SQL99,使用JOIN关键字代替了之前的逗号，并且将连接条件和筛选条件进行了分离，提高阅读性。</p>
<ol start="2">
<li>外连接</li>
</ol>
<blockquote>
<p>查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项，如果没有匹配项，则显示null。</p>
<p>应用场景：一般用于查询主表中有但从表没有的纪录</p>
<p>特点：</p>
<ol>
<li>外连接分主从表，两表的顺序不能任意调换</li>
<li>左连接的话，左边为主表。右连接亦然。</li>
</ol>
<p>语法：<br>
SELECT 查询列表<br>
FROM 表名1 别名<br>
LEFT|RIGHT 【OUTER】 JOIN 表名2 别名<br>
ON 连接条件<br>
WHERE 筛选条件<br>
GROUP BY 分组列表<br>
HAVING 分组后筛选<br>
ORDER BY 排序列表;</p>
</blockquote>
<h3 id="分页查询">分页查询</h3>
<blockquote>
<p>语法:</p>
<p>SELECT 查询列表<br>
FROM 表1 别名<br>
JOIN 表2 别名<br>
ON 连接条件<br>
WHERE 筛选条件<br>
GROUP BY 分组列表<br>
HAVING 分组后筛选<br>
ORDER BY 排序列表<br>
LIMIT 起始条目索引，显示的条目数;</p>
<p>特点：</p>
<ol>
<li>起始条目索引从0开始，如果不写，则就是从0开始显示。</li>
</ol>
</blockquote>
<p>▲执行顺序</p>
<ol>
<li>from子句</li>
<li>join子句</li>
<li>on子句</li>
<li>where子句</li>
<li>group by子句</li>
<li>having子句</li>
<li>select子句</li>
<li>order by子句</li>
<li>limit子句</li>
</ol>
<h3 id="联合查询">联合查询</h3>
<p>当查询结果来自于多张表，但多张表之间没有关联，这个时候往往会使用UNION查询。</p>
<blockquote>
<p>语法“：</p>
<p>SELECT 查询列表 FROM 表1 WHERE 筛选条件<br>
UNION<br>
SELECT 查询列表 FROM 表2 WHERE 筛选条件</p>
<p>特点：</p>
<ol>
<li>列数必须一致。</li>
<li>列名根据第一个表。</li>
<li>UNION会自动去重。可以使用UNION ALL 不去重。</li>
</ol>
</blockquote>
<h2 id="ddl">DDL</h2>
<h3 id="库的管理">库的管理</h3>
<ol>
<li>
<p>创建数据库</p>
<pre><code class="language-SQL">CREATE DATABASE IF NOT EXISTS stuDB;
</code></pre>
</li>
<li>
<p>删除数据库</p>
<pre><code class="language-SQL">DROP DATABASE IF EXISTS stuDB;
</code></pre>
</li>
</ol>
<h3 id="表的管理">表的管理</h3>
<ol>
<li>
<p>创建表</p>
</li>
<li>
<p>修改表</p>
<pre><code class="language-SQL">ALTER TABLE 表名 ADD|MODIFY|CHANGE|DROP|RENAME TO COLUMN 字段名 字段类型 【字段约束】;
</code></pre>
</li>
<li>
<p>删除表</p>
</li>
<li>
<p>复制表</p>
<ul>
<li>仅仅复制表的结构</li>
</ul>
<pre><code class="language-SQL">CREATE TABLE 新表名 LILE 表名
</code></pre>
<ul>
<li>赋值表的结构和数据</li>
</ul>
<pre><code class="language-SQL">CREATE TABLE 新表名 SELECT 需要复制的列名列表 FROM 表名
</code></pre>
</li>
</ol>
<h2 id="dml">DML</h2>
<h3 id="数据的插入">数据的插入</h3>
<blockquote>
<p>语法：</p>
<pre><code class="language-sql">INSERT INTO 表名(字段1,字段2,....) values (值1,值2,...)
</code></pre>
<p>特点：</p>
<ol>
<li>字段和值列表一一对应</li>
<li>数值型的值，不用使用单引号，非数值型的值，必须使用单引号</li>
<li>字段顺序无要求</li>
</ol>
</blockquote>
<h3 id="数据的修改">数据的修改</h3>
<pre><code class="language-sql">update 表名 set 字段名 = 新值,字段名 = 新值,....
WHERE 筛选条件;
</code></pre>
<h3 id="数据的删除">数据的删除</h3>
<ol>
<li>
<p>delete语句</p>
<pre><code class="language-SQL">delete from 表名 where 筛选条件;
</code></pre>
</li>
<li>
<p>truncate语句</p>
<pre><code class="language-sql">truncate from 表名；/删除该表，直接重建结构相同的表
</code></pre>
</li>
</ol>
<p>区别：</p>
<ol>
<li>delete可以添加where条件，truncate不可以。</li>
<li>truncate的效率较高</li>
<li>如果删除带自增长列的表，使用delete删除后，重新插入数据，记录从断点开始。使用truncate记录从1开始。</li>
<li>delete删除数据会返回受影响的行数。</li>
<li>delele删除数据可以支持事务回滚。</li>
</ol>
<h2 id="dcl">DCL</h2>
<p>事务四大特性：ACID</p>
<p>隐式事务：DML的insert、update、delete</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总复习07-IO流]]></title>
        <id>https://codingbear.top/zong-fu-xi-07-io-liu/</id>
        <link href="https://codingbear.top/zong-fu-xi-07-io-liu/">
        </link>
        <updated>2020-10-20T10:33:36.000Z</updated>
        <content type="html"><![CDATA[<p><strong>java路径两种写法&quot;/&quot;和&quot;\\&quot;</strong></p>
<p>最好用/，跨平台都可使用</p>
<h2 id="四大抽象类">四大抽象类</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">输入流</th>
<th style="text-align:center">输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字节流</td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">OutputStream</td>
</tr>
<tr>
<td style="text-align:center">字符流</td>
<td style="text-align:center">Reader</td>
<td style="text-align:center">Writer</td>
</tr>
</tbody>
</table>
<h2 id="理解操作步骤">理解操作步骤</h2>
<ol>
<li>创建源</li>
<li>选择流</li>
<li>操作</li>
<li>释放资源</li>
</ol>
<pre><code class="language-java">/*
 * Copyright (c) 2019.
 * All Rights Reserved,Designed By Mingyu Xiong
 */

package com.ychs.io;

import java.io.*;

/**
 * @author Mingyu Xiong
 * @description:
 * @date 2019/07/30 16:57
 */
public class IOTest01 {
    public static void main(String[] args) {
        //1.创建源
        File src = new File(&quot;E:/repo/Java1014/Java/Day17/abc.txt&quot;);
        //2.选择源
        InputStream is = null;
        try {
            is = new FileInputStream(src);
            //3.操作(读取)
            int temp;
            while ((temp = is.read()) != -1) {
                System.out.println((char)temp);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            //4.释放资源
            try {
                if (null != is) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

</code></pre>
<h2 id="瞬态关键字transient">瞬态关键字transient</h2>
<p>只要被transient修饰了，序列化时这个属性就不会被序列化了。<br>
同时静态修饰也不会被序列化，因为序列化是把对象数据进行持久化存储，而静态的属于类加载时的数据，不会被序列化。</p>
<h2 id="serializable序列化接口">Serializable序列化接口</h2>
<p>当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。</p>
<h2 id="properties类">Properties类</h2>
<p>1 Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串</p>
<p>2 特点</p>
<ul>
<li>Hashtable的子类，Map集合中的方法都可以用</li>
<li>该集合没有泛型，键值都是字符串</li>
<li>它是一个可以持久化的属性集</li>
<li>方法</li>
</ul>
<pre><code>load(InputStream) 把指定流所对应的文件中的数据读取出来，保存到Properties集合中
load(Reader)  
store(OutputStream,comments)把集合中的数据，保存到指定的流所对应的文件中，
参数comments代表对描述信息
store(Writer,comments);
</code></pre>
<p>3 Properties集合，它是唯一一个能与IO流交互的集合</p>
<ul>
<li>添加和获取元素的方法</li>
</ul>
<pre><code>put(key,value)
public Object setProperty(String key, String value)调用 Hashtable的方法put
public Set&lt;String&gt; stringPropertyNames()返回此属性列表中的键集
public String getProperty(String key)用指定的键在此属性列表中搜索属性
</code></pre>
<p>4 将Properties属性集合中内容存储到文件</p>
<ul>
<li>创建Properties集合</li>
<li>添加元素到集合</li>
<li>创建流</li>
<li>把集合中的数据存储到流所对应的文件中</li>
<li>关闭流</li>
</ul>
<p>5 读取属性文件中的数据，并保存到Properties集合中</p>
<ul>
<li>创建集合</li>
<li>创建流对象</li>
<li>把流所对应文件中的数据读取到集合中</li>
<li>关闭流</li>
<li>显示集合中的数据</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总复习06-多线程]]></title>
        <id>https://codingbear.top/zong-fu-xi-06-duo-xian-cheng/</id>
        <link href="https://codingbear.top/zong-fu-xi-06-duo-xian-cheng/">
        </link>
        <updated>2020-10-09T17:10:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程与进程的关系">线程与进程的关系</h2>
<p>线程是CPU调度的最小单元，而进程一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关系。</p>
<h2 id="多线程的实现方案">多线程的实现方案</h2>
<ul>
<li>
<p>继承Thread类，重写run()方法</p>
</li>
<li>
<p>实现Runnable接口</p>
</li>
</ul>
<h2 id="同步和死锁">同步和死锁</h2>
<ul>
<li>同步方法（非静态方法锁对象是this，静态方法锁对象是类名.class）</li>
<li>同步代码块</li>
<li>Lock锁</li>
</ul>
<h4 id="死锁">死锁</h4>
<p>所谓死锁，是指多个线程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<ul>
<li>产生死锁的必要条件
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
</li>
</ul>
<h2 id="并发和并行-串行">并发和并行、串行</h2>
<p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p>串行：按顺序执行。</p>
<h2 id="线程的生命周期">线程的生命周期</h2>
<ol>
<li>
<p>新建</p>
</li>
<li>
<p>就绪</p>
</li>
<li>
<p>运行</p>
</li>
<li>
<p>阻塞</p>
<ul>
<li>
<p>等待阻塞 --运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
</li>
<li>
<p>同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
</li>
<li>
<p>其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
</li>
</ul>
</li>
<li>
<p>死亡</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/10/05/vxhnWVge1JBQyId.png" alt="img" loading="lazy"></figure>
<h2 id="控制线程">控制线程</h2>
<ul>
<li>
<p>sleep()</p>
<p>方法sleep()的作用是在指定的毫秒数内让当前&quot;正在执行的线程&quot;休眠(暂停执行)。 这个&quot;正在执行的线程&quot;是指Thread.currentThread()返回的线程。但是sleep不会释放锁。</p>
<p><strong>Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。</strong></p>
</li>
<li>
<p>yield()</p>
<p>此方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU的时间。但是放弃的时间不确定，有可能刚刚放弃就马上获得CPU时间片。</p>
<p>sleep 方法使当前运行中的线程睡眠一段时间，进入超时等待状态，这段时间的长短是由程序设定的，yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。</p>
<p>yield()也不会释放锁标志。</p>
<p>yield()只是使当前线程重新回到可运行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。</p>
<p>yield()只能使同优先级或更高优先级的线程有执行的机会。</p>
<p>实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为“退让”，它把运行机会让给了同等级的其他线程。</p>
</li>
<li>
<p>join()</p>
<p><strong>join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</strong></p>
<p><strong>join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。</strong></p>
</li>
<li>
<p>wait()和notify()、notifyAll()</p>
<p>这三个方法用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。Synchronized 这个关键字用于保护共享数据，阻止其他线程对共享数据的存取。但是这样程序的流程就很不灵活了，如何才能在当前线程还没退出Synchronized数据块时让其他线程也有机会访问共享数据呢?此时就用这三个方法来灵活控制。</p>
<p>wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志;如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。</p>
</li>
</ul>
<h2 id="线程安全的类">线程安全的类</h2>
<ul>
<li>StringBuffer</li>
<li>Vector</li>
<li>HashTable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总复习05-集合]]></title>
        <id>https://codingbear.top/zong-fu-xi-05-ji-he/</id>
        <link href="https://codingbear.top/zong-fu-xi-05-ji-he/">
        </link>
        <updated>2020-10-09T17:10:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/06/24/yFetxOmnIGWjVP4.png" alt="img" loading="lazy"></figure>
<h5 id="集合和数组的区别">集合和数组的区别：</h5>
<ul>
<li>数组的长度是固定的，集合的长度是可变的。</li>
<li>集合中存储的元素是引用数据类型，集合也叫做“对象容器”，可以是基本数据类型的包装类，也可以是其他复合数据类型。</li>
<li>Java API 中定义好的一系列关于集合的类和接口放在 java .util 包中。</li>
</ul>
<h2 id="collection">Collection</h2>
<p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet和TreeSet。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/06/24/Vqsel1xGbLjhYBF.jpg" alt="img" loading="lazy"></figure>
<p>ArrayList遍历:</p>
<pre><code>  	1. 普通for循环
  	2. 增强for循环
  	3. 迭代器
</code></pre>
<ul>
<li>
<p>Collection和Collections的区别</p>
<blockquote>
<p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。<br>
而java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
</blockquote>
</li>
<li>
<p>Arrays工具类</p>
</li>
<li>
<p>LinkedList</p>
<blockquote>
<p>LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。</p>
</blockquote>
<ul>
<li>
<p>LinkedList&lt;--&gt;ArrayList 通过构造方法和addAll方法转换</p>
<pre><code class="language-java">        LinkedList linkedList = new LinkedList();
        ArrayList arrayList = new ArrayList();
        linkedList.add(arrayList);
        ArrayList arrayList1 = new ArrayList(linkedList);
        LinkedList linkedList1 = new LinkedList(arrayList);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="set">Set</h2>
<p><span style="color:red;font-size:25px">set是无序(存取顺序不同)且不能重复的</span></p>
<p><em><strong>set遍历不能用普通for循环,需要用增强for循环和迭代器</strong></em></p>
<ul>
<li>
<p>HashSet</p>
<ol>
<li>元素唯一，无序，不能重复</li>
<li>底层结构是哈希表结构</li>
<li>元素的存与取的顺序不能保证一致</li>
</ol>
</li>
<li>
<p>LinkedHashSet</p>
<ol>
<li>元素唯一，有序，不能重复</li>
<li>底层结构是 哈希表结构 + 链表结构， 由链表保证元素有序，由哈希表保证元素唯一</li>
<li>元素的存与取的顺序一致</li>
</ol>
</li>
<li>
<p>TreeSet</p>
<p>底层数据结构是红黑树.</p>
</li>
</ul>
<h2 id="map">Map</h2>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/06/24/8Ero5Q4sdRbx1kw.png" alt="QQ图片20200623025012" loading="lazy"></figure>
<h3 id="hashmap集合">HashMap集合</h3>
<p>键是哈希表结构，可以保证键的唯一性。</p>
<p>往map里放数据,遇到相同Key后面的会把前面的覆盖.</p>
<ul>
<li>
<p>Map集合遍历</p>
<ol>
<li>
<p>根据键找值。获取所有键的集合，遍历键的集合，获取到每一个键，根据键找值。</p>
</li>
<li>
<p>根据键值对对象找键和值。</p>
<ul>
<li>获取所有键值对对象的集合</li>
<li>遍历键值对对象的集合，获取到每一个键值对对象</li>
<li>根据键值对对象找键和值</li>
</ul>
</li>
<li>
<p>直接输出值</p>
<pre><code> Collection&lt;E&gt; values = map.values();遍历values
</code></pre>
</li>
</ol>
</li>
<li>
<p>LinkedHashMap 接口的哈希表和链接列表的实现类，具有可预知的迭代顺序。</p>
</li>
</ul>
<h3 id="treemap集合">TreeMap集合</h3>
<p>TreeMap类；可排序；两个构造器； a)无参构造器；元素所在类必须实现Comparable接口； b)带有临时比较器的构造器；临时实现Comparator接口；</p>
<h3 id="hashtable集合">HashTable集合</h3>
<p>HashMap:无序存放,新的操作类,key不允许重复,采用异步处理方式，性能更高，属于非线程安全的操作类。 Hashtable:无序存放,旧的操作类,key不允许重复，采用同步处理方式，性能更低，属于线程安全的操作类。</p>
<p><strong>Map接口和Collection接口的不同</strong> 1、Map是双列的,Collection是单列的 2、Map的键唯一,Collection的子类Set集合的值是不重复的，每个值是唯一的 3、Map集合的数据结构值针对键有效，跟值无关 4、Collection集合的数据结构是针对元素有效</p>
<h1 id="泛型">泛型</h1>
<p>泛型只能使用复合数据类型,泛型引用和创建两端，给出的泛型变量必须相同。</p>
<ul>
<li>
<p>定义</p>
<ul>
<li>
<p>泛型类定义</p>
<p>泛型类中使用泛型</p>
<ul>
<li>成员类型</li>
<li>返回值和参数类型</li>
<li>局部变量的引用上</li>
</ul>
<pre><code>Class&lt;T&gt; type
</code></pre>
</li>
<li>
<p>把泛型定义在方法上</p>
<pre><code>public &lt;T&gt; T add(T x, T y){ 
}
</code></pre>
</li>
<li>
<p>泛型接口</p>
<pre><code>public interface 接口名&lt;泛型类型1…&gt;
</code></pre>
</li>
</ul>
<p>子类的泛型个数&gt;=父类的泛型个数</p>
<p>继承过来的泛型可以不写吗?可以,泛型擦除,变成Object类型</p>
</li>
</ul>
<p>PECS原则</p>
<ol>
<li>“?”不能添加元素</li>
<li>“? extends T”也不能添加元素</li>
<li>“? super T”能添加元素</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[法老-隐藏曲目（feat.戴斯蒙德）]]></title>
        <id>https://codingbear.top/fa-lao-yin-cang-qu-mu-featdai-si-meng-de/</id>
        <link href="https://codingbear.top/fa-lao-yin-cang-qu-mu-featdai-si-meng-de/">
        </link>
        <updated>2020-09-29T18:58:59.000Z</updated>
        <content type="html"><![CDATA[<p>[00:00.00]隐藏曲目 - 法老/戴思蒙德<br>
[00:02.05]作词：法老/戴思蒙德<br>
[00:03.99]作曲：法老/戴思蒙德<br>
[00:06.58]滚动歌词制作：X2<br>
[00:09.69]<br>
[00:21.08]好几年过去哥的技巧依然娴熟<br>
[00:23.08]不考虑前途前路<br>
[00:24.19]肩负小B羡慕善意眼神<br>
[00:25.86]充满魅力让你皈依<br>
[00:27.19]让配戏的归西就像梅西你没戏随时随地勃起<br>
[00:30.37]拴上老道的宝车<br>
[00:31.72]每天深夜在他微博饱读诗书<br>
[00:33.81]练就独特床上技术叫汝师叔<br>
[00:35.82]这圈子唯一敢写这种歌的人是法老蜀黍<br>
[00:38.64]病态男孩只是昙花一现他走投无路<br>
[00:41.21]我有垃圾的设备和人体极限<br>
[00:43.20]GAI爷想买beat时我他妈的随手转他1000<br>
[00:45.96]哥的思想消极<br>
[00:47.16]超级想把李尔新给敲到七窍流血暴击屁眼<br>
[00:50.04]塞屁眼插爽不冰释前嫌<br>
[00:51.87]我恨一个人会拉坨大便<br>
[00:53.41]把它捏成人型然后他妈的亲自打扁<br>
[00:56.33]待会开始我会录很多的干声<br>
[00:58.41]因为我离成为传奇不过也就只差得个癌症<br>
[01:01.39]我的功力儿深到疯癫儿<br>
[01:03.69]惹我请你吃冲拳<br>
[01:06.28]你这lowB请记一点<br>
[01:08.85]你不配suck my dick<br>
[01:11.37]你还在从前水平冬眠<br>
[01:14.10]你只会看我红眼<br>
[01:16.51]我的兄弟儿全都容易儿<br>
[01:19.04]发火拉你去卖批儿<br>
[01:21.85]自以为神的rapper我会像浩克把你干废<br>
[01:24.79]知己没门我是独行侠还烂醉有汗味<br>
[01:27.08]晚辈只想犯罪<br>
[01:28.20]捍卫塔利班专干残废战队<br>
[01:29.98]我在三年前就说要办了马思唯<br>
[01:31.75]我自己都没信但为这性癖让我至今<br>
[01:34.02]还在凭他照片自慰<br>
[01:35.30]明着在家里或者轻轨<br>
[01:36.85]我最爱的女神叫做vava<br>
[01:38.48]有机会一起演出<br>
[01:39.54]我会下药在她的花甲<br>
[01:40.78]我的女粉通篇喊着妈呀<br>
[01:42.40]疯癫的暴跳冲天<br>
[01:43.60]中间充填峰尖的整容脸<br>
[01:45.18]想让我抱着她在浴缸唱陪你过冬天<br>
[01:47.26]我逃到舞池中间<br>
[01:48.53]徐真真过来跟我扭在一起<br>
[01:50.09]酒过三巡之后我们同谋合伙剖了TT<br>
[01:52.58]别着着急急<br>
[01:53.41]站好队看齐去稍稍息息<br>
[01:54.90]嘿嘿鼠尾草去年拜访过DZ<br>
[01:57.24]刀刃专砍短小的鸡鸡<br>
[01:58.87]开启杀戮的续集<br>
[02:00.02]Ladys hater们<br>
[02:01.33]我这么牛逼还不快打出GG<br>
[02:02.65]我的功力儿深到疯癫儿<br>
[02:05.01]惹我请你吃冲拳<br>
[02:07.52]你这lowB请记一点<br>
[02:10.22]你不配suck my dick<br>
[02:12.54]你还在从前水平冬眠<br>
[02:15.14]你只会看我红眼<br>
[02:17.66]我的兄弟儿全都容易儿<br>
[02:20.22]发火拉你去卖批儿<br>
[02:23.00]像原始人一样出击<br>
[02:24.51]用骨刺对付你们的现代武器<br>
[02:25.90]熟悉我的都知道我的初心<br>
[02:27.28]送伪黑怕出殡<br>
[02:28.25]靠讲讲就能爆破原子弹堪比普京<br>
[02:30.57]我的女朋友蒋蒋<br>
[02:31.35]长的就像是大话西游的朱茵<br>
[02:32.92]网上暴躁现实却口袋只有五毛还要捐给动物基金<br>
[02:35.89]穷的就剩面镜子<br>
[02:36.95]我也提醒自己帅的像黎明<br>
[02:38.59]你模仿阿姆！<br>
[02:39.61]你们这些网民屁民<br>
[02:40.60]我不仅模仿阿姆还要打爆你的阿母<br>
[02:42.49]杀猪般的跑着比巴卜不停地咬着<br>
[02:44.07]说唱圈最狠的角色把你追着<br>
[02:45.53]你只能躲在车里手握着丁丁就像是阿杜<br>
[02:48.49]我现在接近狂怒<br>
[02:49.68]新街口还当自己是new J.Cole<br>
[02:51.53]但是搞半天说唱圈对你们却是no接受<br>
[02:53.99]张晗你的声音就像是得了肺结核<br>
[02:55.85]非主流和喊麦结合<br>
[02:57.17]我绝招就是打家劫舍<br>
[02:58.72]你说我对不上拍子<br>
[02:59.52]可你根本玩不了这种结构的flow<br>
[03:00.90]我玩说唱没什么伟大的梦想<br>
[03:01.95]单纯为了打爆打脸你们这些废物的头<br>
[03:03.88]我的功力儿深到疯癫儿<br>
[03:06.18]惹我请你吃冲拳<br>
[03:08.69]你这lowB请记一点<br>
[03:11.25]你不配suck my dick<br>
[03:13.84]你还在从前水平冬眠<br>
[03:16.47]你只会看我红眼<br>
[03:18.91]我的兄弟儿全都容易儿<br>
[03:21.54]发火拉你去卖批儿<br>
[03:24.30]把头给我伸过来<br>
[03:28.95]我有个宝贝想给你们看看<br>
[03:33.92]快把那头给我给我伸过来<br>
[03:38.98]我有个宝贝想给你们看看<br>
[03:44.65]我的功力儿深到疯癫儿<br>
[03:46.93]惹我请你吃冲拳<br>
[03:49.54]你这lowB请记一点<br>
[03:52.09]你不配suck my dick<br>
[03:54.64]你还在从前水平冬眠<br>
[03:57.22]你只会看我红眼<br>
[03:59.78]我的兄弟儿全都容易儿<br>
[04:02.41]发火拉你去卖批儿<br>
[04:05.16]我们不在乎你们全都一起上<br>
[04:09.99]我们不在乎你们全都一起躁<br>
[04:15.23]我们不在乎你们全都一起上<br>
[04:20.33]我们不在乎你们全都全都全都一起躁<br>
[04:26.37]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[总复习04-面向对象]]></title>
        <id>https://codingbear.top/zong-fu-xi-mian-xiang-dui-xiang/</id>
        <link href="https://codingbear.top/zong-fu-xi-mian-xiang-dui-xiang/">
        </link>
        <updated>2020-09-25T15:57:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向对象四大基本特性">面向对象四大基本特性</h2>
<h3 id="封装">封装</h3>
<p>封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
<p>好处：</p>
<ol>
<li>将变化隔离。</li>
<li>便于使用。</li>
<li>提高重用性。</li>
<li>提高安全性。</li>
</ol>
<p>封装原则：</p>
<ol>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性都隐藏，提供公共方法对其访问。如，getXXX，setXXX。</li>
</ol>
<p>注意事项：</p>
<ul>
<li>私有仅仅是封装的一种体现而已。</li>
<li>private关键字：是一个权限修饰符，用于修饰成员(成员变量和成员函数)，被私有化的成员只在本类中有效。</li>
<li>常用场景之一：将成员变量私有化，对外提供对应的set、get方法对其进行访问，提高对数据访问的安全性。</li>
</ul>
<h3 id="继承">继承</h3>
<blockquote>
<p>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</p>
<p>通过 extends 关键字让类与类之间产生继承关系。</p>
<p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类可以称为子类，单独这个类称为父类或者超类。</p>
</blockquote>
<p>注意事项：</p>
<ul>
<li>子类可以直接访问父类中的非私有的属性和行为。</li>
<li><strong>子类无法继承父类中私有的内容。</strong></li>
<li>父类怎么来的？共性不断向上抽取而来的。</li>
<li><strong>父类的构造方法不可以继承。</strong></li>
</ul>
<p><em><strong>继承的特点</strong></em></p>
<p>1．在Java中，类只支持单继承，不允许多重继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/06/24/FqWIKXQuZv62bTJ.png" alt="1500704447701" loading="lazy"></figure>
<p>2．多个类可以继承一个父类，例如下面这种情况是允许的。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/06/24/6anqby3NfxcI28E.png" alt="1500704467099" loading="lazy"></figure>
<p>3．在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。例如下面这种情况是允许的。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/06/24/oQTSAEOY8IHcPxB.png" alt="1500704487847" loading="lazy"></figure>
<p>4．在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的示例中，B类是A类的子类，同时又是C类的父类。</p>
<p>Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。 原因：因为多继承容易出现问题。两个父类中有相同的方法，子类到底要执行哪一个是不确定的。</p>
<h3 id="多态">多态</h3>
<blockquote>
<p>定义：某一类事物的多种存在形态。</p>
</blockquote>
<p><span style="font-size:24px;color:red;background-color:yellow">编译时类型和运行时类型不一致就会出现多态。相同类型的变量调用同一个方法时呈现出多种不同的行为特征，这就是多态。最终多态体现为父类引用变量可以指向子类对象。</span></p>
<p>多态的实现分为两种:</p>
<ul>
<li>向上转型</li>
<li>向下转型</li>
</ul>
<p><span style="font-size:24px;color:red;background-color:yellow">同一个父类的方法会被不同的子类重写。在调用方法时，调用的是各个子类重写后的方法。</span></p>
<p><em><strong>当子父类中出现同名的成员变量时，全部调用父类的成员变量，因为变量没有多态性，因为系统总是试图访问它编译时所定义的成员变量。</strong></em></p>
<blockquote>
<p>多态调用该变量时：<br>
编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。<br>
运行时期：也是调用引用型变量所属的类中的成员变量。<br>
简单记：编译和运行都参考等号的左边。编译运行看左边。</p>
</blockquote>
<h3 id="抽象">抽象</h3>
<p><strong>抽象定义：抽象就是从多个事物中将共性的、本质的内容抽取出来。</strong></p>
<ol>
<li>
<p>抽象类</p>
<p>Java允许在定义方法时不写方法体，不包含方法体的方法为抽象方法，抽象方法必须使用abstract关键字来修饰。</p>
<p>Java中可以定义没有方法体的方法，该方法的具体实现由子类完成，该方法称为抽象方法，包含抽象方法的类就是抽象类。</p>
<p><span style="color:red;background-color:purple">抽象类不一定有抽象方法,包含抽象方法的类一定是抽象类.</span></p>
<p>抽象类不可以new创建对象,但是抽象类有构造方法.</p>
</li>
<li>
<p>抽象类的使用</p>
<ul>
<li>定义一个子类继承抽象类</li>
<li>复写抽象类中所有的抽象方法</li>
</ul>
</li>
</ol>
<h2 id="包">包</h2>
<ul>
<li>
<p>import</p>
<p>import后面的*只能代表类，不能代表包。</p>
<p>import static 导入静态成员</p>
</li>
</ul>
<h2 id="对象和类">对象和类</h2>
<p>自己写了构造方法，系统将不再生成默认无参构造方法。</p>
<p>对象在构造方法执行之前就已经产生了。</p>
<h2 id="instanceof运算符">instanceof运算符</h2>
<p>用来判断前面的对象是否是后面的类或者其子类、实现类的实例。前面的操作符编译时类型需要与后面的相同或者具有父子继承关系，否自编译出错。</p>
<p>对象 instanceof 类名</p>
<h2 id="访问权限关键字">访问权限关键字</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th style="text-align:center">当前类</th>
<th style="text-align:center">同包下的类</th>
<th style="text-align:center">子类</th>
<th style="text-align:center">不同包且无继承关系的类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td>private</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h2 id="值传递和引用传递">值传递和引用传递</h2>
<p>值传递不会改变实参，引用传递会改变实参。不可改变的final类也可以理解成值传递。</p>
<h2 id="super和this关键字">super和this关键字</h2>
<p style="color:red;">静态方法里不可以使用super和this关键字</p>
<p><font color=red style="background-color:yellow;"> 可以通过this()和super()调用构造方法，必须放在第一行,普通方法中不能调用。</font></p>
<h2 id="static关键字">static关键字</h2>
<ol>
<li>static可以修饰什么</li>
</ol>
<ul>
<li>属性(静态属性、静态变量、类变量)</li>
<li>一般方法(静态方法、类方法)</li>
<li>游离语句块(静态语句代码块)</li>
<li>内部类</li>
</ul>
<ol start="2">
<li>static关键字注意事项</li>
</ol>
<ul>
<li>在静态方法中是没有super和this关键字的</li>
<li>静态方法只能访问静态的成员变量和静态的成员方法</li>
<li>在Java中规定不能将方法体内的局部变量声明为static</li>
</ul>
<h2 id="final关键字">final关键字</h2>
<p>作用：</p>
<ol>
<li>声明类：声明类的时候表示该类不能再被继承</li>
<li>声明方法：声明方法的时候表示该方法不能被子类重写</li>
<li>声明变量：声明变量的时候表示该变量变成常量（常量：一旦赋值之后，里面的值不能再变）</li>
</ol>
<p><span style="color:red;background-color:yellow">用final修饰复合数据类型的时候，引用不能重新赋值，但里面的内容可以重新赋值。</span></p>
<p>final修饰方法形参时，形参只可以用传参初始化，不可以在方法体内对形参赋值。</p>
<p>常见的Final类：</p>
<ul>
<li>所有的包装类</li>
<li>String/StringBuilder/StringBuffer</li>
<li>Math</li>
<li>Class</li>
<li>System</li>
<li>java.time包下的除了Clock和ZoneId之外全都是</li>
</ul>
<h2 id="类的初始化顺序">类的初始化顺序</h2>
<p><strong>父类静态游离块 &gt; 子类静态游离块 &gt; 父类游离块 &gt; 父类构造函数 &gt; 子类游离块 &gt; 子类构造函数</strong></p>
<p style="color:red;font-size:20px">所有的变量初始化完，才会执行构造方法</p>
<h2 id="可变参数">可变参数</h2>
<p>可变长参数的底层是数组，访问的方式用for循环。</p>
<h2 id="内部类">内部类</h2>
<p>访问特点：<span style="color:red;background-color:yellow">内部类可以直接访问外部类中的成员，包括私有成员。而外部类要访问内部类中的成员必须要建立内部类的对象。</span></p>
<h3 id="内部类和外部类的相互调用">内部类和外部类的相互调用</h3>
<ol>
<li>外部类访问内部类：</li>
</ol>
<blockquote>
<p>内部类被static修饰：可以直接new</p>
<p>Inner in = new Inner();</p>
<p>内部类没有被static修饰:得先new出来外部类的实例，再new内部类的</p>
<p>Inner in = new Outer().new Inner();</p>
</blockquote>
<ol start="2">
<li>内部类访问外部类同名方法或变量
<ul>
<li>使用外部类变量：外部类名.this.变量名</li>
<li>使用外部类方法：外部类名.this.方法名()</li>
</ul>
</li>
</ol>
<h3 id="内部类的分类">内部类的分类</h3>
<ol>
<li>
<p>成员内部类</p>
<ul>
<li>
<p>非静态内部类</p>
</li>
<li>
<p>静态内部类</p>
<p>创建静态内部类的对象时，不需要外部类的对象，可以直接创建。</p>
</li>
<li>
<p>匿名内部类</p>
</li>
</ul>
</li>
<li>
<p>方法内部类</p>
<p>不能使用修饰符，只能在方法内使用。</p>
</li>
<li>
<p>匿名内部类</p>
<p>定义：就是内部类的简化写法。 前提：内部类必须继承或实现一个外部类或者接口,但两者不可兼得。 格式：new 外部类名或者接口名(){覆盖类或者接口中的代码，(也可以自定义内容。)} 简单理解：就是建立一个带内容的外部类或者接口的子类匿名对象。</p>
<p>内部类定义在成员位置上，可以被private、static成员修饰符修饰。被static修饰的内部类只能访问外部类中 的静态成员。</p>
<p>如果内部类中定义了静态成员，该内部类也必须是静态的！</p>
<ul>
<li>继承式</li>
<li>接口式</li>
<li>参数式</li>
</ul>
</li>
</ol>
<h2 id="接口和抽象类的区别">接口和抽象类的区别</h2>
<h3 id="接口">接口</h3>
<ul>
<li>成员变量<strong>默认</strong>用　<code>public static final</code>修饰</li>
<li>方法<strong>默认</strong>是<code>public abstract</code> 修饰</li>
<li>jdk1.8 接口中还可以声明有方法体的方法，但是必须要有 <code>default</code> 修饰 <strong>或者</strong> <code>static</code> 修饰 ，而且这两个修饰符不能同时存在 。还可以用 stricfp 关键字修饰方法 ，只能和static搭配使用。</li>
<li>JDK 1.9时，接口中的方法可以是private的。主要是为了提取冗余代码，以便我们的API客户端无法看到它们。</li>
</ul>
<h3 id="区别">区别</h3>
<ul>
<li>接口没有构造方法</li>
<li>单继承多实现</li>
<li>接口可以有静态方法和默认方法，抽象类和普通类一样</li>
<li>接口里只能定义静态常量，抽象类可以定普通成员变量</li>
</ul>
<h2 id="重载和重写">重载和重写</h2>
<p>重载：同一个类中的方法，名字相同，参数列表不同，与返回值无关</p>
<p>重写：发生在继承关系中，两同两小一大原则</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[艾福杰尼-KORLA]]></title>
        <id>https://codingbear.top/ai-fu-jie-ni-korla/</id>
        <link href="https://codingbear.top/ai-fu-jie-ni-korla/">
        </link>
        <updated>2020-09-22T16:00:22.000Z</updated>
        <content type="html"><![CDATA[<p>[00:00.00]艾福杰尼-KORLA<br>
[00:02.08]词：艾福杰尼<br>
[00:03.45]曲：艾福杰尼<br>
[00:04.86]编曲：顺德(SDOUND)<br>
[00:06.45]滚动歌词制作：X2<br>
[00:08.60]<br>
[00:22.83]这鼓点不断敲手势不用我去教<br>
[00:25.42]绝对熟悉的味道装满压力的背包<br>
[00:28.07]用韵脚描绘勾勒出场景唯妙唯肖<br>
[00:30.85]让滑落嘴角的眼泪穿越这悠长隧道<br>
[00:33.85]又是即将起飞的航班和未来的憧憬<br>
[00:36.72]这首歌不需要你共鸣<br>
[00:38.16]和我兄弟懂就行<br>
[00:39.38]现在一切就绪把所有的烦恼都丢尽<br>
[00:42.15]只要有颗忠心就算这里又断了通讯<br>
[00:44.98]除了真挚的微笑 其他都与我无关<br>
[00:47.66]Hater 看我开着保时捷在路口急转弯 skr<br>
[00:50.79]曾经对我失败你多期盼<br>
[00:52.40]你颈椎都快被气断<br>
[00:53.53]看我身边兄弟从不换<br>
[00:54.81]这首发力还不到一半<br>
[00:56.41]Be the burning fire<br>
[00:57.58]Fire makes you higher<br>
[00:58.83]Little town has a big dream<br>
[01:00.86]That's one luv<br>
[01:01.78]Be the burning fire<br>
[01:03.10]Fire makes you higher<br>
[01:04.40]Little town has a big dream<br>
[01:06.14]That's one luv<br>
[01:07.48]Be the burning fire<br>
[01:08.66]Fire makes you higher<br>
[01:10.08]Little town has a big dream<br>
[01:11.80]That's one luv one luv one luv one luv<br>
[01:18.58]库尔勒的 motherf<strong>ker<br>
[01:19.91]也是库尔勒的 king<br>
[01:21.27]天生我就带股拼劲儿<br>
[01:22.53]这是库尔勒人的命<br>
[01:23.94]把我正能量都塞进歌里带给你听<br>
[01:26.57]从新疆出发经过西安一路带去北京<br>
[01:29.45]让我告诉所有梦想成为 rapper 的兄弟<br>
[01:32.02]不管你身处何方 或者漂泊异地<br>
[01:34.88]也许忍气吞声 可能生活节拘<br>
[01:37.80]但如果不经历苦难<br>
[01:39.14]又怎能带回好消息<br>
[01:40.62]翻过最后那座山 之后是崎岖的路<br>
[01:43.44]穿越油田沙漠一片绿洲就是我的 hood<br>
[01:46.16]经过沙漠洗礼冒险家们迈出第一步<br>
[01:48.96]不曾感到羞耻感觉出生在这儿 so cool<br>
[01:52.30]So good<br>
[01:53.21]Home's so good<br>
[01:54.51]I feel good everything I do<br>
[01:57.50]I feel good<br>
[01:58.64]I feel good<br>
[02:00.24]I feel the soul in my spirit and I do<br>
[02:03.35]Be the burning fire<br>
[02:04.53]Fire makes you higher<br>
[02:05.84]Little town has a big dream<br>
[02:07.68]That's one luv<br>
[02:08.75]Be the burning fire<br>
[02:10.08]Fire makes you higher<br>
[02:11.54]Little town has a big dream<br>
[02:13.19]That's one luv<br>
[02:14.27]Be the burning fire<br>
[02:15.65]Fire makes you higher<br>
[02:17.02]Little town has a big dream<br>
[02:18.88]That's one luv one luv one luv one luv<br>
[02:25.05]<br>
[02:25.36]喝不完的好酒 还有唠不完的磕<br>
[02:28.02]能够安逸生活因为前人拒绝懒惰<br>
[02:30.82]就让这酒水漫过酒杯一起放声高歌<br>
[02:33.58]只因善良的孩子永远比那邪恶的多<br>
[02:36.57]年轻时和兄弟打赌 一定做得到<br>
[02:39.39]不只做得到 越做越叼 越做越骚<br>
[02:42.00]看过演出的 homie 都说我现场特别燥<br>
[02:44.93]以前瞧不上的sucker<br>
[02:46.48]现在都给我悄悄<br>
[02:48.05]牛逼从不忘本 给0996 加分<br>
[02:50.43]我像只勤劳的蜂蜜<br>
[02:51.75]不断给梦想采花粉<br>
[02:53.23]总有人想占你便宜 把你汗水瓜分<br>
[02:56.03]Man I f</strong>k u up<br>
[02:57.36]0457 是我家人<br>
[02:58.87]听着 boom bap 就像我的心脏<br>
[03:01.79]如果你也喜欢请和我们一起清唱<br>
[03:04.43]就算我的歌声<br>
[03:05.66]传遍980 万个平方<br>
[03:07.34]我也永远忘不了我家乡什么形状<br>
[03:10.16]Be the burning fire<br>
[03:11.40]Fire makes you higher<br>
[03:12.89]Little town has a big dream<br>
[03:14.72]That's one luv<br>
[03:15.62]Be the burning fire<br>
[03:17.10]Fire makes you higher<br>
[03:18.51]Little town has a big dream<br>
[03:20.30]That's one luv<br>
[03:21.58]Be the burning fire<br>
[03:22.69]Fire makes you higher<br>
[03:24.05]Little town has a big dream<br>
[03:25.71]That's one luv one luv one luv one luv<br>
[03:31.49]</p>
]]></content>
    </entry>
</feed>